#include <cstdio>
#include <cstdlib>
#include <fstream>

#include "graphcut\GraphCutSegmentation.h"
#include "lazy\LazySnapping.h"

#define LBUTTON_OFF	0
#define LBUTTON_ON 	1

#define HINT_BACKGROUND 0
#define HINT_FOREGROUND 1

#define SIZE_RATIO 0.005f

#define DST "result\\"
#define SRC "dataset\\"

std::ofstream ofs("result\\time.csv");

GraphCutSegmentation gc;
LazySnapping ls;

cv::Mat original_img, type, hint_img;
std::vector<std::string> inputList;
std::vector<cv::Point> hintObj, hintBkg;
int    lbutton_flag, hint_flag;

void params_init() {
	lbutton_flag = LBUTTON_OFF;
	hint_flag = HINT_BACKGROUND;
}

void argument_disp() {

	printf("Usage:\n");
	printf("<binary> <mode> <input_file>\n");
	printf("where:\n");
	printf("	- binary: the compiled executable file, e.g InteractiveGraphCut.exe\n");
	printf("	- mode: 0 for only creating hints, 1 for creating hints and segmenting images\n");
	printf("	- input_file: the file contains the list of input images, generated by GenDataList.ps1\n");

}

void mouseHandler(int event, int x, int y, int flags, void *param) {

	cv::Point curPoint(x, y);

	switch (event) {

	case CV_EVENT_LBUTTONUP:
		lbutton_flag = LBUTTON_OFF;
		break;

	case CV_EVENT_LBUTTONDOWN:
		lbutton_flag = LBUTTON_ON;

	case CV_EVENT_MOUSEMOVE: {

		cv::Rect imgRect(cv::Point(), hint_img.size());

		if (lbutton_flag == LBUTTON_ON) {


			if (!imgRect.contains(curPoint))
				return;

			cv::Scalar seedColor;
			int circleSize = int(std::min(hint_img.cols, hint_img.rows) * SIZE_RATIO);
			switch (hint_flag) {

			case HINT_BACKGROUND:

				//hintBkg.push_back(curPoint);
				cv::circle(type, curPoint, circleSize, { GraphCutSegmentation::BACKGROUND }, -1);
				cv::circle(hint_img, curPoint, circleSize, { 255, 0, 0 }, -1);
				break;

			case HINT_FOREGROUND:

				//hintObj.push_back(curPoint);
				cv::circle(type, curPoint, circleSize, { GraphCutSegmentation::OBJECT }, -1);
				cv::circle(hint_img, curPoint, circleSize, { 0, 255, 0 }, -1);
				break;
			}

			

		}

		cv::imshow("Image", hint_img);

	}
							 break;

	case CV_EVENT_RBUTTONDOWN:

		hint_flag = 1 - hint_flag;

		if (hint_flag == HINT_BACKGROUND) {

			fprintf(stdout, "hints on background...\n");

		}
		else {

			fprintf(stdout, "hints on foreground...\n");

		}

		break;
	}

}

void setHint(const std::string& fileName) {

	original_img = cv::imread(SRC + fileName + ".jpg");
	type = cv::Mat::zeros(original_img.size(), CV_8S);

	if (original_img.empty()) {
		std::cout << fileName << " Image reading error!\n";
		return;
	}

	std::ifstream f(SRC + fileName + ".hint");

	if (f.good()) {
		std::cout << fileName << "'s hint exists.\n";
		f.close();
		return;
	}
	f.close();

	hint_img = original_img.clone();
	hintObj.clear();
	hintBkg.clear();

	cv::namedWindow("Image", CV_WINDOW_NORMAL);
	cv::setMouseCallback("Image", mouseHandler, NULL);
	cv::imshow("Image", original_img);
	cv::waitKey(0);
	cv::destroyAllWindows();
	cv::imwrite(DST + fileName + "_hint.jpg", hint_img, std::vector<int>{CV_IMWRITE_JPEG_QUALITY, 100});

	for (int r = 0; r < type.rows; r++)
		for (int c = 0; c < type.cols; c++) {
			switch (type.at<char>(r, c)) {
			case GraphCutSegmentation::BACKGROUND:
				hintBkg.push_back({ c, r });
				break;
			case GraphCutSegmentation::OBJECT:
				hintObj.push_back({ c, r });
				break;
			}
		}

	std::ofstream hintFile(SRC + fileName + ".hint");
	hintFile << hintBkg.size() << std::endl;
	for (auto &p : hintBkg)
		hintFile << p.x << " " << p.y << std::endl;
	hintFile << hintObj.size() << std::endl;
	for (auto &p : hintObj)
		hintFile << p.x << " " << p.y << std::endl;
	hintFile.close();

}

void getObj(const std::string& fileName) {

	// Read input image
	original_img = cv::imread(SRC + fileName + ".jpg");
	if (original_img.empty()) {
		std::cout << fileName << " Hint file missing error!\n";
		return;
	}
	
	ofs << fileName << ',';

	// Read hints
	type = cv::Mat::zeros(cv::Size(original_img.cols, original_img.rows), CV_8S);
	hintObj.clear();
	hintBkg.clear();

	std::cout << "starting to segment image" << fileName << std::endl;
	std::ifstream hintFile(SRC + fileName + ".hint");
	int nSeed;
	hintFile >> nSeed;
	for (int i = 0; i < nSeed; i++) {
		int x, y;
		hintFile >> x >> y;
		type.at<char>(y, x) = GraphCutSegmentation::BACKGROUND;
		hintBkg.push_back({ x, y });
		ls.setUpdateB(true);
	}
	hintFile >> nSeed;
	for (int i = 0; i < nSeed; i++) {
		int x, y;
		hintFile >> x >> y;
		type.at<char>(y, x) = GraphCutSegmentation::OBJECT;
		hintObj.push_back({ x, y });
		ls.setUpdateF(true);
	}

	// Measure interactive graphcut
	uint64_t start, end;

	cv::Mat outMask;
	gc.createDefault();
	start = cv::getTickCount();
	gc.segment(original_img, type, outMask);
	end = cv::getTickCount();
	gc.cleanGarbage();
	ofs << double(end - start) / cv::getTickFrequency() << ',';

	cv::Mat obj;
	original_img.copyTo(obj, outMask);
	//cv::imshow("gcObj", obj);
	cv::imwrite(DST + fileName + "_graphcut_object.jpg", obj, std::vector<int>{CV_IMWRITE_JPEG_QUALITY, 100});

	// Measure lazy snapping
	ls.setSourceImage(original_img);
	ls.setBackgroundPoints(hintBkg);
	ls.setForegroundPoints(hintObj);

	start = cv::getTickCount();
	ls.initMarkers();
	ls.runMaxFlow();
	end = cv::getTickCount();

	ofs << double(end - start) / cv::getTickFrequency() << "\n";
	obj = ls.getImageColor();
	//cv::imshow("lsObj", obj);
	cv::imwrite(DST + fileName + "_lazy_object.jpg", obj, std::vector<int>{CV_IMWRITE_JPEG_QUALITY, 100});

	//cv::waitKey(0);
	//cv::destroyAllWindows();
}

void testLambda(const std::string& inputFile) {
	std::string tmpFile = inputFile.substr(0, inputFile.find_last_of('.'));
	original_img = cv::imread(inputFile);
	setHint(tmpFile);
	const std::vector<float> lambda{ 0.0, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64 };
	for (auto lambdaVal : lambda) {
		
		type = cv::Mat::zeros(cv::Size(original_img.cols, original_img.rows), CV_8S);

		std::cout << "starting to segment image" << tmpFile << " " << lambdaVal <<  std::endl;
		std::ifstream hintFile(SRC + tmpFile + ".hint");
		int nSeed;
		hintFile >> nSeed;
		for (int i = 0; i < nSeed; i++) {
			int x, y;
			hintFile >> x >> y;
			type.at<char>(y, x) = GraphCutSegmentation::BACKGROUND;
		}
		hintFile >> nSeed;
		for (int i = 0; i < nSeed; i++) {
			int x, y;
			hintFile >> x >> y;
			type.at<char>(y, x) = GraphCutSegmentation::OBJECT;
		}

		// Measure interactive graphcut
		uint64_t start, end;

		cv::Mat outMask;
		gc.createDefault();
		gc.setRegionBoundaryRelation(lambdaVal);
		start = cv::getTickCount();
		gc.segment(original_img, type, outMask);
		end = cv::getTickCount();
		gc.cleanGarbage();
		ofs << double(end - start) / cv::getTickFrequency() << ',';

		cv::Mat obj;
		original_img.copyTo(obj, outMask);
		//cv::imshow("gcObj", obj);
		cv::imwrite(DST + tmpFile + "_graphcut_object" + std::to_string(lambdaVal) + ".jpg", obj, std::vector<int>{CV_IMWRITE_JPEG_QUALITY, 100});
	}
}

void readInputFile(const std::string& inputFile) {

	ofs << "Test,InteractiveGraphCut,LazySnapping\r\n";

	std::ifstream ifs(inputFile);
	if (!ifs.good()) {
		argument_disp();
		exit(1);
	}
	std::string tmpFile;
	while (true) {
		std::getline(ifs, tmpFile);
		if (ifs.eof())
			break;
		tmpFile = tmpFile.substr(0, tmpFile.find_last_of('.'));
		inputList.push_back(tmpFile);
	}
		
	for (auto &file : inputList)
		setHint(file);

	for (auto &file : inputList)
		getObj(file);

}

void switchMode(int mode, const std::string& inputFile) {
	params_init();
	switch (mode) {
	case 0:
		testLambda(inputFile);
		break;
	case 1:
		readInputFile(inputFile);
		break;

	default:
		argument_disp();
	}
}

int main(int argc, char** argv) {

	switch (argc) {
	case 3:
		switchMode(std::stoi(argv[1]), argv[2]);
		break;
	default:
		argument_disp();
	}

	return 0;
	
}

